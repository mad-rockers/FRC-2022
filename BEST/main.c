#pragma config(UART_Usage, UART1, uartUserControl, baudRate1200, IOPins, None, None)
#pragma config(Motor,  port2,           leftDrive,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           rightDrive,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           elevator,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           lever,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           leftDropper,   tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           rightDropper,  tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           IR,            tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// custom baud rate set code

typedef unsigned long  uint32_t;
typedef unsigned short uint16_t;

typedef struct
{
  uint16_t SR;
  uint16_t RESERVED0;
  uint16_t DR;
  uint16_t RESERVED1;
  uint16_t BRR;
  uint16_t RESERVED2;
  uint16_t CR1;
  uint16_t RESERVED3;
  uint16_t CR2;
  uint16_t RESERVED4;
  uint16_t CR3;
  uint16_t RESERVED5;
  uint16_t GTPR;
  uint16_t RESERVED6;
} USART_TypeDef;

/* Peripheral memory map */
#define PERIPH_BASE           ((unsigned long)0x40000000)
#define APB1PERIPH_BASE       PERIPH_BASE
#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
#define USART2                ((USART_TypeDef *) USART2_BASE)
#define USART3                ((USART_TypeDef *) USART3_BASE)

void setBaud( const TUARTs nPort, int baudRate ) {
    uint32_t tmpreg = 0x00, apbclock = 0x00;
    uint32_t integerdivider = 0x00;
    uint32_t fractionaldivider = 0x00;

    /* pclk1 - 36MHz */
    apbclock = 36000000;

    /* Determine the integer part */
    integerdivider = ((0x19 * apbclock) / (0x04 * (baudRate)));
    tmpreg = (integerdivider / 0x64) << 0x04;

    /* Determine the fractional part */
    fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
    tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & 0x0F;

    /* Write to USART BRR */
    USART_TypeDef *uart = USART2;
    if( nPort == UART2 ) {
      uart = USART3;
    }
    uart->BRR = (uint16_t)tmpreg;
}

//Trackers
bool reversed = false;
bool driving = true;

//Lever Values
int forward_half = 0;
int forward_full = 0;
int neutral = 0;
int back_half = 0;
int back_full = 0;

//IR Codes
int drive = 0x5A;
int rotate = 0x3C;
int lift = 0x33;
int drive_low = 0x99;
int drive_med = 0xA5;
int drive_high = 0xC3;
int rotate_low = 0x69;
int rotate_med = 0x96;
int rotate_high = 0x0F;

task main()
{
	setBaud(UART1, 600);
	while(true) {
		//Robot control
		if(driving) {
			//Driving
			if(!reversed) {
				if(abs(vexRT[Ch3]) > 20) {
					motor[leftDrive] = vexRT[Ch3];
				}
				else {
					motor[leftDrive] = 0;
				}
				if(abs(vexRT[Ch2]) > 20) {
					motor[rightDrive] = vexRT[Ch2];
				}
				else {
					motor[rightDrive] = 0;
				}
			}
			else {
				if(abs(vexRT[Ch3]) > 20) {
					motor[rightDrive] = -vexRT[Ch3];
				}
				else {
					motor[rightDrive] = 0;
				}
				if(abs(vexRT[Ch2]) > 20) {
					motor[leftDrive] = -vexRT[Ch2];
				}
				else {
					motor[leftDrive] = 0;
				}
			}
			if(vexRT[Btn8D] == 1) {
				while (vexRT[Btn8D] == 1) {}
				reversed = !reversed;
			}

		  //Wheel Droppers
		  if(vexRT[Btn7R] == 1)
			{
				motor[rightDropper] = 100;
				motor[leftDropper] = 100;
			}
			else if(vexRT[Btn7L] == 1)
			{
		  	motor[leftDropper] = -100;
		  	motor[rightDropper] = -100;
		  }
		  else
		  {
		  	motor[leftDropper] = 0;
		  	motor[rightDropper] = 0;
		  }

		  //Elevator
		  if(vexRT[Btn7U] == 1)
			{
				motor[elevator] = 100;
			}
			else if(vexRT[Btn7D] == 1)
			{
				motor[elevator] = -100;
			}
			else
			{
				motor[elevator] = 0;
			}

		  //IR Stick
			if(vexRT[Btn8U] == 1)
			{
				while(vexRT[Btn8U] == 1) {}
				motor[IR] = 45;
				driving = false;
			}
		}

		//Squeaky Control
		else {
			//Driving
			if(abs(vexRT[Ch2]) > 20) {
				if(vexRT[Ch2] < -109) {
					sendChar(UART1, drive);
					sendChar(UART1, drive_high);
					motor[lever] = back_full;
				}
				else if(vexRT[Ch2] < -91) {
					sendChar(UART1, drive);
					sendChar(UART1, drive_med);
					motor[lever] = back_full;
				}
				else if(vexRT[Ch2] < -73) {
					sendChar(UART1, drive);
					sendChar(UART1, drive_low);
					motor[lever] = back_full;
				}
				else if(vexRT[Ch2] < -55) {
					sendChar(UART1, drive);
					sendChar(UART1, drive_high);
					motor[lever] = back_half;
				}
				else if(vexRT[Ch2] < -37) {
					sendChar(UART1, drive);
					sendChar(UART1, drive_med);
					motor[lever] = back_half;
				}
				else if(vexRT[Ch2] < -20) {
					sendChar(UART1, drive);
					sendChar(UART1, drive_low);
					motor[lever] = back_half;
				}
				else if(vexRT[Ch2] < 37) {
					sendChar(UART1, drive);
					sendChar(UART1, drive_low);
					motor[lever] = forward_half;
				}
				else if(vexRT[Ch2] < 55) {
					sendChar(UART1, drive);
					sendChar(UART1, drive_med);
					motor[lever] = forward_half;
				}
				else if(vexRT[Ch2] < 73) {
					sendChar(UART1, drive);
					sendChar(UART1, drive_high);
					motor[lever] = forward_half;
				}
				else if(vexRT[Ch2] < 91) {
					sendChar(UART1, drive);
					sendChar(UART1, drive_low);
					motor[lever] = forward_full;
				}
				else if(vexRT[Ch2] < 109) {
					sendChar(UART1, drive);
					sendChar(UART1, drive_med);
					motor[lever] = forward_full;
				}
				else {
					sendChar(UART1, drive);
					sendChar(UART1, drive_high);
					motor[lever] = forward_full;
				}
			}

			//Rotattion
			else if(abs(vexRT[Ch4]) > 20) {
				if(vexRT[Ch2] < -109) {
					sendChar(UART1, rotate);
					sendChar(UART1, rotate_high);
					motor[lever] = back_full;
				}
				else if(vexRT[Ch4] < -91) {
					sendChar(UART1, rotate);
					sendChar(UART1, rotate_med);
					motor[lever] = back_full;
				}
				else if(vexRT[Ch4] < -73) {
					sendChar(UART1, rotate);
					sendChar(UART1, rotate_low);
					motor[lever] = back_full;
				}
				else if(vexRT[Ch4] < -55) {
					sendChar(UART1, rotate);
					sendChar(UART1, rotate_high);
					motor[lever] = back_half;
				}
				else if(vexRT[Ch4] < -37) {
					sendChar(UART1, rotate);
					sendChar(UART1, rotate_med);
					motor[lever] = back_half;
				}
				else if(vexRT[Ch4] < -20) {
					sendChar(UART1, rotate);
					sendChar(UART1, rotate_low);
					motor[lever] = back_half;
				}
				else if(vexRT[Ch4] < 37) {
					sendChar(UART1, rotate);
					sendChar(UART1, rotate_low);
					motor[lever] = back_half;
				}
				else if(vexRT[Ch4] < 55) {
					sendChar(UART1, rotate);
					sendChar(UART1, rotate_med);
					motor[lever] = back_half;
				}
				else if(vexRT[Ch4] < 73) {
					sendChar(UART1, rotate);
					sendChar(UART1, rotate_high);
					motor[lever] = back_half;
				}
				else if(vexRT[Ch4] < 91) {
					sendChar(UART1, rotate);
					sendChar(UART1, rotate_low);
					motor[lever] = back_full;
				}
				else if(vexRT[Ch4] < 109) {
					sendChar(UART1, rotate);
					sendChar(UART1, rotate_med);
					motor[lever] = back_full;
				}
				else {
					sendChar(UART1, rotate);
					sendChar(UART1, rotate_high);
					motor[lever] = back_full;
				}
			}

			//Lift
			else if(abs(vexRT[Btn5U]) == 1) {
				sendChar(UART1, lift);
				motor[lever] = back_half;
			}
			else if(abs(vexRT[Btn5D]) == 1) {
				sendChar(UART1, lift);
				motor[lever] = back_full;
			}
			else if(abs(vexRT[Btn6U]) == 1) {
				sendChar(UART1, lift);
				motor[lever] = forward_half;
			}
			else if(abs(vexRT[Btn6D]) == 1) {
				sendChar(UART1, lift);
				motor[lever] = forward_full;
			}

			else {
				motor[lever] = neutral;
			}

			//IR Stick
			if(vexRT[Btn8U] == 1)
			{
				while(vexRT[Btn8U] == 1) {}
				motor[IR] = -127;
				driving = true;
			}
		}
	}
}
